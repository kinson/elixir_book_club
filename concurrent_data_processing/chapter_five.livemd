# Chapter 5

## Okay

```elixir
Mix.install([
  {:broadway, "~> 0.6"},
  {:broadway_rabbitmq, "~> 0.6"},
  {:amqp, "~> 1.6"}
])
```

```elixir
defmodule ApplicationBroadway do
  def start(_type, _args) do
    children = [
      BookingsPipeline
    ]

    opts = [strategy: :one_for_one, name: Tickets.Supervisor]

    Supervisor.start_link(children, opts)
  end
end
```

### Introduction to Broadway

* the `GenStage` pipeline generated by Broadway is designed according to current best practices

  * It is fault tolerant and performs graceful shutdowns out of the box

* broadway requires options to start

  * `:name` is used as a prefix when naming processes
  * `:producer` contains config about the source of events
  * `:processors` allows us to configure the stage processes that receive the messages and do most of the work

*

```elixir
defmodule BookingsPipeline do
  use Broadway

  @producer BroadwayRabbitMQ.Producer

  @producer_config [
    queue: "bookings_queue",
    declare: [durable: true],
    on_failure: :reject_and_requeue
  ]

  def start_link(_args) do
    options = [
      name: BookingsPipeline,
      producer: [module: {@producer, @producer_config}],
      processors: [default: []],
      batchers: [default: []]
    ]

    Broadway.start_link(__MODULE__, options)
  end

  def handle_message(_processor, message, _context) do
    %{data: %{event: event, user: user}} = message

    if Tickets.tickets_available?(event) do
      Tickets.create_ticket(user, event)
      Tickets.send_email(user)

      IO.inspect(message, label: "Message")
    else
      Broadway.Message.failed(message, "bookings-closed")
    end
  end

  def handle_failed(messages, _context) do
    IO.inspect(messages, label: "Failed messages")

    Enum.map(messages, fn
      %{status: {:failed, "bookings-closed"}} = message ->
        Broadway.Message.configure_ack(message, on_failure: :reject)

      message ->
        message
    end)
  end

  def prepare_messages(messages, _context) do
    messages =
      Enum.map(messages, fn message ->
        Broadway.Message.update_data(message, fn data ->
          [event, user_id] = String.split(data, ", ")
          %{event: event, user_id: user_id}
        end)
      end)

    users = Tickets.users_by_ids(Enum.map(messages, & &1.data.user_id))

    # put users in messages

    Enum.map(messages, fn message ->
      Broadway.Message.update_data(message, fn data ->
        user = Enum.find(users, &(&1.id == data.user_id))
        Map.put(data, :user, user)
      end)
    end)
  end

  def handle_batch(_batcher, messages, batch_info, _context) do
    IO.inspect(batch_info, label: "#{inspect(self())} batch")
    messages
  end
end
```

```elixir
defmodule Tickets do
  # removed after using AMQP
  # def tickets_available?("cinema") do
  #   Process.sleep(Enum.random(100..200))
  #   false
  # end

  def tickets_available?(_event) do
    Process.sleep(Enum.random(100..200))
    true
  end

  def create_ticket(_user, _event) do
    Process.sleep(Enum.random(250..1000))
  end

  def send_email(_user) do
    Process.sleep(Enum.random(100..250))
  end

  @users [
    %{id: "1", email: "foo@example.com"},
    %{id: "2", email: "bar@example.com"},
    %{id: "3", email: "baz@example.com"}
  ]

  def users_by_ids(ids) when is_list(ids) do
    # normally this would be a db query
    Enum.filter(@users, &(&1.id in ids))
  end
end
```

### prepare_messages callback

* lets us do work in bulk when receiving messages
  * e.g. fetch or preload info from the db
  * do it here rather than `handle_message/3`
  * runs before `handle_message/3` and receives a list of messages to iterate over and update with more info

### handle_failed callback

* gives us the ability to check what messages have failed and why and decide if we want to take further action
* can use `configure_ack` to acknowledge failed messages so they are not requeued
  *

## Batching Messages

* batching messages lets you group relevant messages

```elixir
defmodule IEXHelpers do
  def send_messages(num_messages) do
    {:ok, connection} = AMQP.Connection.open()
    {:ok, channel} = AMQP.Channel.open(connection)

    Enum.each(1..num_messages, fn _ ->
      event = Enum.random(["cinema", "musical", "play"])
      user_id = Enum.random(1..3)
      AMQP.Basic.publish(channel, "", "bookings_queue", "#{event},#{user_id}")
    end)

    AMQP.Connection.close(connection)
  end
end
```

#### `handle_batch/4`

* all code within the callback runs concurrently in a separate batch processor
* each "batcher" will start a single batch processor by default which runs the code in `handle_batch/4` to process the given group of mesages

`%BatchInfo{}`

* `batcher` is the batcher group and belongs to one of the groups defined in `starlink/1`
* `:batch_key` is an id for a gorup of messages in the batch
* `:partition` is the partition key if configured
* `:size` is the number of messages in the batch
