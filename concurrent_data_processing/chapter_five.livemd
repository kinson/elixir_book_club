# Chapter 5

## Okay

```elixir
Mix.install([
  {:broadway, "~> 0.6"},
  {:broadway_rabbitmq, "~> 0.6"}
])
```

```elixir
defmodule ApplicationBroadway do
  def start(_type, _args) do
    children = [
      BookingsPipeline
    ]

    opts = [strategy: :one_for_one, name: Tickets.Supervisor]

    Supervisor.start_link(children, opts)
  end
end
```

### Introduction to Broadway

* the `GenStage` pipeline generated by Broadway is designed according to current best practices

  * It is fault tolerant and performs graceful shutdowns out of the box

* broadway requires options to start

  * `:name` is used as a prefix when naming processes
  * `:producer` contains config about the source of events
  * `:processors` allows us to configure the stage processes that receive the messages and do most of the work

*

```elixir
defmodule BookingsPipeline do
  use Broadway

  @producer BroadwayRabbitMQ.Producer

  @producer_config [
    queue: "bookings_queue",
    declare: [durable: true],
    on_failure: :reject_and_requeue
  ]

  def start_link(_args) do
    options = [
      name: BookingsPipeline,
      producer: [module: {@producer, @producer_config}],
      processors: [default: []]
    ]

    Broadway.start_link(__MODULE__, options)
  end

  def handle_message(_processor, message, _context) do
    %{data: %{event: event, user: user}} = message

    if Tickets.tickets_available?(event) do
      Tickets.create_ticket(user, event)
      Tickets.send_email(user)

      IO.inspect(message, label: "Message")
    else
      Broadway.Message.failed(message, "bookings-closed")
    end
  end

  def handle_failed(messages, _context) do
    IO.inspect(messages, label: "Failed messages")

    Enum.map(messages, fn
      %{status: {:failed, "bookings-closed"}} = message ->
        Broadway.Message.configure_ack(message, on_failure: :reject)

      message ->
        message
    end)
  end

  def prepare_messages(messages, _context) do
    messages =
      Enum.map(messages, fn message ->
        Broadway.Message.update_data(message, fn data ->
          [event, user_id] = String.split(data, ", ")
          %{event: event, user_id: user_id}
        end)
      end)

    users = Tickets.users_by_ids(Enum.map(messages, & &1.data.user_id))

    # put users in messages

    Enum.map(messages, fn message ->
      Broadway.Message.update_data(message, fn data ->
        user = Enum.find(users, &(&1.id == data.user_id))
        Map.put(data, :user, user)
      end)
    end)
  end
end
```

```elixir
defmodule Tickets do
  def tickets_available?("cinema") do
    Process.sleep(Enum.random(100..200))
    false
  end

  def tickets_available?(_event) do
    Process.sleep(Enum.random(100..200))
    true
  end

  def create_ticket(_user, _event) do
    Process.sleep(Enum.random(250..1000))
  end

  def send_email(_user) do
    Process.sleep(Enum.random(100..250))
  end

  @users [
    %{id: "1", email: "foo@example.com"},
    %{id: "2", email: "bar@example.com"},
    %{id: "3", email: "baz@example.com"}
  ]

  def users_by_ids(ids) when is_list(ids) do
    # normally this would be a db query
    Enum.filter(@users, &(&1.id in ids))
  end
end
```

### prepare_messages callback

* lets us do work in bulk when receiving messages
  * e.g. fetch or preload info from the db
  * do it here rather than `handle_message/3`
  * runs before `handle_message/3` and receives a list of messages to iterate over and update with more info

### handle_failed callback

* gives us the ability to check what messages have failed and why and decide if we want to take further action
* can use `configure_ack` to acknowledge failed messages so they are not requeued
*

## Batching Messages



* batching messages lets you group relevant messages
