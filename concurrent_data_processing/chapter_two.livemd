# Chapter Two

## Starting With a Basic GenServer

```elixir
defmodule SendServer do
  use GenServer
end
```

### `use GenServer`

* automatically injects the line `@behavior GenServer`
* provides a default `GenServer` implementation by injecting all functions required by the `GenServer` behaviour

## GenServer Callbacks in Depth

```elixir
defmodule SendServer do
  use GenServer

  def init(args) do
    IO.puts("Received Args #{inspect(args)}")
    max_retries = Keyword.get(args, :max_retries, 5)
    state = %{emails: [], max_retries: max_retries}
    {:ok, state}
  end
end
```

```elixir
# try it out
{:ok, pid} = GenServer.start(SendServer, max_retries: 1)

GenServer.stop(pid)
```

* other options for returning in `init`

<!-- livebook:{"force_markdown":true} -->

```elixir
{:ok, state}
{:ok, state, {:continue, term}}
:ignore
{:stop, reason}
```

* `{:continue, term}` is a good way to do initialization logic without blocking the response
  * `{:ok, state, {:continue, :fetch_from_db}}` will call `handle_continue` callback with `:fetch_from_db`
* `{:stop, reason}` will stop the process from continuing, if under a supervisor, it will be restarted
* `:ignore` is same as above but it will not be restarted if under a supervisor

#### `handle_continue`

Acceptable Return Values:

* `{:noreply, new_state}`
* `{:noreply, new_state, {:continue, term}}`
* `{:stop, reason, new_state}`

```elixir
defmodule SendServer do
  use GenServer

  def init(args) do
    IO.puts("Received Args #{inspect(args)}")
    max_retries = Keyword.get(args, :max_retries, 5)
    state = %{emails: [], max_retries: max_retries}
    {:ok, state}
  end

  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end
end
```
